package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	importPathFlag              = StringSlice("import_path", []string{}, "A mapping of proto imports to TS imports, as `PROTO_PATH=TS_PATH` pairs (this flag can be specified more than once). If the proto does not end with '.proto' then these act as directory prefixes.")
	strictImportsFlag           = flag.Bool("strict_imports", false, "If set, all directly imported protos must have an -import_path specified. This prevents the plugin from \"guessing\" import paths based on the proto path. This is also useful when integrating with build systems where all direct dependencies must be explicitly specified.")
	importModuleSpecifierEnding = flag.String("import_module_specifier_ending", "", "Suffix to apply to generated import module specifiers. May need to be set to \".js\" in rare cases.")

	outFlag = flag.String("out", "", "Output file `path`. If this is set and multiple protos are provided as input, the generated code for all protos will be written to this file. Any '.ts' or '.js' extension will be ignored.")

	importPaths = map[string]string{}
)

const (
	fileDescriptorMessageTypeTagNumber int32 = 4
	fileDescriptorEnumTypeTagNumber    int32 = 5
	fileDescriptorServiceTagNumber     int32 = 6
	descriptorFieldTagNumber           int32 = 2
	descriptorNestedTypeTagNumber      int32 = 3
	descriptorEnumTypeTagNumber        int32 = 4
	enumDescriptorValueTagNumber       int32 = 2
	serviceMethodTagNumber             int32 = 2

	varintWireType int32 = 0
	i64WireType    int32 = 1
	lenWireType    int32 = 2
	i32WireType    int32 = 5
	// note: group wire types are unsupported

	wireTypeMask = 7
)

func main() {
	if err := run(); err != nil {
		logf("error: %s", err)
		os.Exit(1)
	}
}

func run() error {
	// Note: flags will not actually be available here when invoked via
	// protoc. This is just to support running `./protoc-gen-protobufjs -help`
	flag.Parse()

	req, err := readRequest()
	if err != nil {
		return fmt.Errorf("failed to read CodeGenerationRequest from stdin: %s", err)
	}

	os.Args = append(os.Args, strings.Split(req.GetParameter(), ":")...)
	flag.Parse()

	for _, p := range *importPathFlag {
		parts := strings.SplitN(p, "=", 2)
		if len(parts) != 2 {
			return fmt.Errorf("invalid import_path %q: should be of the form `PROTO_PATH_PREFIX=TS_PATH_PREFIX`", p)
		}
		protoPath, tsPath := parts[0], parts[1]
		if !strings.HasSuffix(protoPath, "/") && !strings.HasSuffix(protoPath, ".proto") {
			protoPath += "/"
		}
		if !strings.HasSuffix(tsPath, "/") && !strings.HasSuffix(protoPath, ".proto") {
			tsPath += "/"
		}
		importPaths[protoPath] = tsPath
	}

	if os.Getenv("VERBOSE") == "1" {
		// Throw away all source code info other than comments & the fields they
		// apply to.
		for _, f := range req.GetProtoFile() {
			var nonEmptyLocations []*descriptorpb.SourceCodeInfo_Location
			for _, l := range f.GetSourceCodeInfo().GetLocation() {
				if l.GetLeadingComments() != "" {
					l.Span = nil // span is unused
					nonEmptyLocations = append(nonEmptyLocations, l)
				}
			}
			f.GetSourceCodeInfo().Location = nonEmptyLocations
		}
		jb, _ := protojson.MarshalOptions{Multiline: true}.Marshal(req)
		logf("request: %s\n", string(jb))
	}

	var features uint64
	features |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	res := &pluginpb.CodeGeneratorResponse{
		SupportedFeatures: &features,
	}

	idx := BuildIndex(req)
	// If --out is set, write all sources to a single file.
	if *outFlag != "" {
		c := newCodegen(idx, *outFlag, req.GetFileToGenerate()...)
		outs, err := c.Generate()
		if err != nil {
			return err
		}
		res.File = append(res.File, outs...)
	} else {
		// Otherwise write each source named according to the .proto path
		for _, path := range req.GetFileToGenerate() {
			out := strings.TrimSuffix(path, ".proto") + ".ts"
			c := newCodegen(idx, out, path)
			outs, err := c.Generate()
			if err != nil {
				return err
			}
			res.File = append(res.File, outs...)
		}
	}

	return writeResponse(res)
}

// Namespace represents a namespace tree to be generated.
type Namespace struct {
	Name string
	// FileSymbols []*SymbolSet
	Files    []*descriptorpb.FileDescriptorProto
	Children map[string]*Namespace
}

func sortedKeys[K string, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return keys[i] < keys[j]
	})
	return keys
}

// Codegen generates code for a single proto file descriptor.
type Codegen struct {
	Index *Index

	// Generated TypeScript declarations.
	d *TS
	// Generated JS implementation.
	j *TS

	// Paths to the protos to be translated to TS.
	Paths []string
	// Out is the file being generated by this codegen.
	Out string

	// Map of input file path to map of SourceCodeInfo_Location.path stringified
	// list repr like "[4 5 1 2 0 3]" to SourceCodeInfo_Location.leading_comment
	Comments map[string]map[string]string

	// Map of symbol -> import path
	ImportedSymbols map[string]string
	// Map of import path -> symbol
	ImportedFiles map[string]string
}

func newCodegen(idx *Index, out string, paths ...string) *Codegen {
	// Map of file path -> serialized
	comments := map[string]map[string]string{}
	for _, path := range paths {
		comments[path] = map[string]string{}
		for _, l := range idx.Files[path].GetSourceCodeInfo().GetLocation() {
			if l.GetLeadingComments() == "" {
				continue
			}
			comments[path][fmt.Sprint(l.GetPath())] = l.GetLeadingComments()
		}
	}
	return &Codegen{
		d:               &TS{},
		j:               &TS{JS: true},
		Index:           idx,
		Paths:           paths,
		Out:             out,
		Comments:        comments,
		ImportedSymbols: map[string]string{},
		ImportedFiles:   map[string]string{},
	}
}

func (c *Codegen) Generate() ([]*pluginpb.CodeGeneratorResponse_File, error) {
	j, d := c.j, c.d

	// Check that all dependencies are indexed, since we need to know how to
	// import their types
	for _, path := range c.Paths {
		for _, d := range c.Index.Files[path].GetDependency() {
			if _, ok := c.Index.Files[d]; !ok {
				return nil, fmt.Errorf("missing dependency %q in code generation request", d)
			}
		}
	}

	var outs []*pluginpb.CodeGeneratorResponse_File

	d.DefaultImport("protobufjs/minimal", "* as $protobuf")

	j.DefaultImport("protobufjs/minimal", "* as $protobuf")
	j.L("// Common aliases")
	j.L("const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;")
	j.L("// Exported root namespace")
	j.L("const $root = {};")
	root := c.buildNamespaceTree()
	for _, name := range sortedKeys(root.Children) {
		c.generateNamespace(root.Children[name], name)
	}

	outNoExt := c.Out
	for _, ext := range []string{".js", ".ts", ".d.ts"} {
		outNoExt = strings.ReplaceAll(outNoExt, ext, "")
	}

	declarationName := outNoExt + ".d.ts"
	declarationContent := d.String()
	declaration := &pluginpb.CodeGeneratorResponse_File{
		Name:    &declarationName,
		Content: &declarationContent,
	}
	outs = append(outs, declaration)

	jsName := outNoExt + ".js"
	jsContent := j.String()
	js := &pluginpb.CodeGeneratorResponse_File{
		Name:    &jsName,
		Content: &jsContent,
	}
	outs = append(outs, js)

	return outs, nil
}

func (c *Codegen) buildNamespaceTree() *Namespace {
	root := &Namespace{Children: map[string]*Namespace{}}
	for _, path := range c.Paths {
		f := c.Index.Files[path]
		parts := strings.Split(f.GetPackage(), ".")
		ns := root
		for _, part := range parts {
			c := ns.Children[part]
			if c == nil {
				c = &Namespace{Name: part, Children: map[string]*Namespace{}}
				ns.Children[part] = c
			}
			ns = c
		}
		ns.Files = append(ns.Files, f)
	}
	return root
}

func (c *Codegen) generateNamespace(ns *Namespace, nsPath string) {
	j, d := c.j, c.d
	d.Lf("export namespace %s {", ns.Name)
	if strings.Contains(nsPath, ".") {
		j.Lf("%s.%s = (() => {", getPart(nsPath, ".", -2), ns.Name)
	} else {
		j.Lf("$root.%s = (() => {", ns.Name)
	}
	j.Lf("const %s = {};", ns.Name)
	for _, f := range ns.Files {
		c.generate(f, []int32{}, nsPath, f.GetMessageType(), f.GetEnumType(), f.GetService())
	}
	for _, name := range sortedKeys(ns.Children) {
		c.generateNamespace(ns.Children[name], nsPath+"."+name)
	}
	d.L("}")
	j.Lf("return %s;", ns.Name)
	j.L("})();")
	if !strings.Contains(nsPath, ".") {
		j.Lf("export const %s = $root.%s;", ns.Name, ns.Name)
	}
}

func (c *Codegen) generate(file *descriptorpb.FileDescriptorProto, sourcePath []int32, ns string, messages []*descriptorpb.DescriptorProto, enums []*descriptorpb.EnumDescriptorProto, services []*descriptorpb.ServiceDescriptorProto) {
	j, d := c.j, c.d
	curNS := getPart(ns, ".", -1)

	// Generate message type interfaces
	for messageIndex, messageType := range messages {
		messageFieldTag := fileDescriptorMessageTypeTagNumber
		if len(sourcePath) > 0 {
			messageFieldTag = descriptorNestedTypeTagNumber
		}
		messagePath := append(sourcePath, int32(messageFieldTag), int32(messageIndex))

		// Message interface type
		d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(messagePath)])
		d.Lf("export interface I%s {", messageType.GetName())
		for fieldIndex, field := range messageType.Field {
			fieldPath := append(messagePath, descriptorFieldTagNumber, int32(fieldIndex))

			d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(fieldPath)])
			d.Lf("%s?: %s;", field.GetJsonName(), c.typeAnnotation(field))
		}
		d.L("}")

		// Message class type + implementation
		d.Lf("export class %s implements I%s {", messageType.GetName(), messageType.GetName())
		j.Lf("%s.%s = (() => {", curNS, messageType.GetName())
		j.Lf("class %s {", messageType.GetName())
		// Declare fields (to implement interface)
		for _, field := range messageType.GetField() {
			d.Lf("%s: %s;", field.GetJsonName(), c.typeAnnotation(field))
		}

		// Oneof getters/setters
		var numOneofs int32
		for _, field := range messageType.GetField() {
			if field.OneofIndex != nil && field.GetOneofIndex()+1 > numOneofs {
				numOneofs = field.GetOneofIndex() + 1
			}
		}
		if numOneofs > 0 {
			oneofFieldNames := make([][]string, int(numOneofs))
			for _, field := range messageType.GetField() {
				// Don't generate oneof API for optionals; this is for backwards
				// compatibility, which we don't need because we explicitly support
				// optionals.
				if field.GetProto3Optional() {
					continue
				}

				if field.OneofIndex != nil {
					i := *field.OneofIndex
					oneofFieldNames[i] = append(oneofFieldNames[i], field.GetJsonName())
				}
			}
			for i, decl := range messageType.GetOneofDecl() {
				fieldNames := oneofFieldNames[i]
				if len(fieldNames) == 0 {
					continue
				}

				fieldStrings := make([]string, 0, len(fieldNames))
				for _, f := range fieldNames {
					fieldStrings = append(fieldStrings, fmt.Sprintf(`"%s"`, f))
				}

				fieldNameType := strings.Join(fieldStrings, " | ")
				fieldNameArray := "[" + strings.Join(fieldStrings, ", ") + "]"

				// TODO: maybe more performant in some cases to only iterate over own
				// properties of `this`
				d.Lf("/**")
				d.Lf(" * Returns the `%s` oneof field name that is set,", oneofFieldName(decl))
				d.Lf(" * or undefined if none is set.")
				d.Lf(" */")
				d.Lf("get %s(): %s | undefined;", oneofFieldName(decl), fieldNameType)

				j.Lf("get %s() {", oneofFieldName(decl))
				j.Lf("for (const key of %s) {", fieldNameArray)
				j.L("if (this[key] !== null && this[key] !== undefined) return key;")
				j.L("}")
				j.L("}")

				d.Lf("/**")
				d.Lf(" * Sets which `%s` oneof field is set", oneofFieldName(decl))
				d.Lf(" * by deleting any other fields in the oneof that might be set.")
				d.Lf(" */")
				d.Lf("set %s(name: %s | undefined): void;", oneofFieldName(decl), fieldNameType)

				j.Lf("set %s(name) {", oneofFieldName(decl))
				j.Lf("for (const key of %s) {", fieldNameArray)
				j.L("if (key !== name) delete this[key];")
				j.L("}")
				j.L("}")
			}
		}

		// Constructor
		d.Lf("constructor(properties?: I%s): %s;", messageType.GetName(), messageType.GetName())
		j.Lf("constructor(properties) {")
		// All repeated fields and maps are initialized to empty
		for _, f := range messageType.GetField() {
			if c.isMapField(f) {
				j.Lf("this.%s = {};", f.GetJsonName())
				continue
			}

			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf("this.%s = [];", f.GetJsonName())
				continue
			}
		}

		j.L("if (properties) {")
		j.Lf("for (let key of Object.keys(properties)) {")
		j.L("if (properties[key] != null) this[key] = properties[key];")
		j.L("}")
		j.L("}")
		j.L("}")

		// Message.create()
		d.Lf("static create(properties?: I%s): %s;", messageType.GetName(), messageType.GetName())
		j.L("static create(properties) {")
		j.Lf("return new %s(properties)", messageType.GetName())
		j.L("}")

		//
		// Encode method
		//

		d.Lf("static encode(message: I%s, writer?: $protobuf.Writer): $protobuf.Writer;", messageType.GetName())
		j.Lf("static encode(message, writer) {")
		j.L("if (!writer) writer = $Writer.create();")
		for _, f := range messageType.GetField() {

			// Map fields (encode as repeated map entry message)
			if c.isMapField(f) {
				j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("for (const key of Object.keys(message.%s)) {", f.GetJsonName())
				mapEntryType := c.Index.MessageTypes[f.GetTypeName()]
				// Map entries always exactly two fields: key, then value
				kf := mapEntryType.GetField()[0]
				vf := mapEntryType.GetField()[1]
				begin := fmt.Sprintf("writer.uint32(%d).fork()", f.GetNumber()<<3|lenWireType)
				encodeKey := fmt.Sprintf(".uint32(%d).%s(key)", kf.GetNumber()<<3|wireType(kf), encodeMethodName(kf))
				if vf.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					classReference := c.resolveTypeName(vf.GetTypeName(), "$root.")
					j.L(begin + encodeKey + ";")
					j.Lf("%s.encode(message.%s[key], writer.uint32(%d).fork()).ldelim().ldelim();", classReference, f.GetJsonName(), vf.GetNumber()<<3|wireType(vf))
				} else {
					encodeValue := fmt.Sprintf(".uint32(%d).%s(message.%s[key])", vf.GetNumber()<<3|wireType(vf), encodeMethodName(vf), f.GetJsonName())
					j.L(begin + encodeKey + encodeValue + ".ldelim();")
				}
				j.L("}")
				j.L("}")
				continue
			}

			// Packed repeated fields
			if isPackedField(f) {
				j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("writer.uint32(%d).fork();", f.GetNumber()<<3|lenWireType)
				j.Lf("for (const element of message.%s) {", f.GetJsonName())
				j.Lf("writer.%s(element)", encodeMethodName(f))
				j.Lf("}")
				j.L("writer.ldelim();")
				j.L("}")
				continue
			}

			// Non-packed repeated fields
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("for (const element of message.%s) {", f.GetJsonName())
				if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
					j.Lf("%s.encode(element, writer.uint32(%d).fork()).ldelim();", classReference, f.GetNumber()<<3|lenWireType)
				} else {
					j.Lf("writer.uint32(%d).%s(element);", f.GetNumber()<<3|wireType(f), encodeMethodName(f))
				}
				j.L("}")
				j.L("}")
				continue
			}

			// Non-repeated fields
			j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
			if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				// TODO: handle groups (see genTypePartial in protobufjs encoder.js)
				classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
				j.Lf("%s.encode(message.%s, writer.uint32(%d).fork()).ldelim();", classReference, f.GetJsonName(), f.GetNumber()<<3|lenWireType)
			} else {
				j.Lf("writer.uint32(%d).%s(message.%s);", f.GetNumber()<<3|wireType(f), encodeMethodName(f), f.GetJsonName())
			}
			j.L("}")
			continue
		}
		j.L("return writer;")
		j.L("}") // encode

		//
		// Decode method
		//

		d.Lf("static decode(reader: $protobuf.Reader | Uint8Array, length?: number): %s;", messageType.GetName())
		j.Lf("static decode(reader, length) {")
		j.L("if (!(reader instanceof $Reader)) reader = $Reader.create(reader);")
		j.L("let end = length === undefined ? reader.len : reader.pos + length;")
		j.Lf("let message = new %s();", messageType.GetName())
		j.L("let key, value;")
		j.L("while (reader.pos < end) {")
		j.L("let tag = reader.uint32();")
		j.L("switch (tag >>> 3) {")
		for _, f := range messageType.GetField() {
			j.Lf("case %d: {", f.GetNumber())
			(func() {
				// Map fields
				if c.isMapField(f) {
					j.Lf("if (message.%s === $util.emptyObject) message.%s = {};", f.GetJsonName(), f.GetJsonName())
					j.L("let end2 = reader.uint32() + reader.pos;")
					entryType := c.Index.MessageTypes[f.GetTypeName()]
					kf := entryType.GetField()[0]
					vf := entryType.GetField()[1]
					j.Lf("key = %s;", c.defaultValueExpression(kf))
					j.Lf("value = %s;", c.defaultValueExpression(vf))
					j.L("while (reader.pos < end2) {")
					j.L("let tag2 = reader.uint32();")
					j.L("switch (tag2 >>> 3) {")

					j.L("case 1: {")
					j.Lf("key = reader.%s();", encodeMethodName(kf))
					j.L("break;")
					j.L("}")

					j.L("case 2: {")
					if vf.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
						classReference := c.resolveTypeName(vf.GetTypeName(), "$root.")
						j.Lf("value = %s.decode(reader, reader.uint32());", classReference)
					} else {
						j.Lf("value = reader.%s();", encodeMethodName(vf))
					}
					j.L("break;")
					j.L("}")

					j.L("}") // switch
					j.Lf("message.%s[key] = value;", f.GetJsonName())
					j.L("}") // while
					return
				}

				// Packable (always check for forward and backward compatibility)
				if isPackableField(f) {
					// Note: the ".length" condition makes sure we replace the
					// $util.emptyArray with a new mutable array
					j.Lf("if (!message.%s || !message.%s.length) {", f.GetJsonName(), f.GetJsonName())
					j.Lf("message.%s = [];", f.GetJsonName())
					j.L("}")
					j.Lf("if ((tag & %d) === %d) {", wireTypeMask, lenWireType)
					j.L("let end2 = reader.uint32() + reader.pos;")
					j.Lf("while (reader.pos < end2) message.%s.push(reader.%s());", f.GetJsonName(), encodeMethodName(f))
					j.L("} else {")
					j.Lf("message.%s.push(reader.%s());", f.GetJsonName(), encodeMethodName(f))
					j.L("}")
					return
				}

				// Non-packable repeated fields
				if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
					// Note: the ".length" condition makes sure we replace the
					// $util.emptyArray with a new mutable array
					j.Lf("if (!message.%s || !message.%s.length) {", f.GetJsonName(), f.GetJsonName())
					j.Lf("message.%s = [];", f.GetJsonName())
					j.L("}")
					if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
						classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
						j.Lf("message.%s.push(%s.decode(reader, reader.uint32()));", f.GetJsonName(), classReference)
					} else {
						j.Lf("message.%s.push(reader.%s());", f.GetJsonName(), encodeMethodName(f))
					}
					return
				}

				// Non-repeated fields
				if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
					j.Lf("message.%s = %s.decode(reader, reader.uint32());", f.GetJsonName(), classReference)
				} else {
					j.Lf("message.%s = reader.%s();", f.GetJsonName(), encodeMethodName(f))
				}
			})()
			j.L("break;")
			j.L("}")
		}
		j.L("default: {")
		j.Lf("reader.skipType(tag & %d);", wireTypeMask)
		j.L("break;")
		j.L("}")
		j.L("}") // switch
		j.L("}") // while
		j.L("return message;")
		j.L("}") // decode()

		//
		// toObject method
		//
		d.Lf("static toObject(message: %s, options: $protobuf.IConversionOptions): Record<string, any>;", messageType.GetName())
		j.L("static toObject(message, options = {}) {")
		j.L("const object = {};")
		// Init arrays
		j.L("if (options.arrays || options.defaults) {")
		for _, f := range messageType.GetField() {
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf("object.%s = [];", f.GetJsonName())
			}
		}
		j.L("}")
		// Init maps
		j.L("if (options.objects || options.defaults) {")
		for _, f := range messageType.GetField() {
			if c.isMapField(f) {
				j.Lf("object.%s = {};", f.GetJsonName())
			}
		}
		j.L("}")
		// Init default values
		j.L("if (options.defaults) {")
		for _, f := range messageType.GetField() {
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED || c.isMapField(f) || f.GetProto3Optional() || f.OneofIndex != nil {
				continue
			}
			if c.isLong(f.GetType()) {
				j.L("if ($util.Long) {")
				j.Lf("let long = new $util.Long(0, 0, %t)", c.isUnsigned(f.GetType()))
				j.Lf(`object.%s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;`, f.GetJsonName())
				j.L("} else {")
				j.Lf(`object.%s = options.longs === String ? "0" : 0;`, f.GetJsonName())
				j.L("}")
				continue
			}
			if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_BYTES {
				j.L("if (options.bytes === String) {")
				j.Lf(`object.%s = ""`, f.GetJsonName())
				j.L("} else {")
				j.Lf("object.%s = [];", f.GetJsonName())
				j.Lf("if (options.bytes !== Array) {")
				j.Lf("object.%s = $util.newBuffer(object.%s);", f.GetJsonName(), f.GetJsonName())
				j.L("}")
				j.L("}")
				continue
			}
			if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
				j.Lf(`object.%s = options.enums === String ? "%s" : 0`, f.GetJsonName(), c.enumZeroValue(f).GetName())
				continue
			}
			j.Lf("object.%s = %s;", f.GetJsonName(), c.defaultValueExpression(f))
		}
		j.L("}")
		// Convert message fields
		j.L("let keys;")
		for _, f := range messageType.GetField() {
			if c.isMapField(f) {
				mapEntryType := c.Index.MessageTypes[f.GetTypeName()]
				vf := mapEntryType.GetField()[1]
				j.Lf("if (message.%s && (keys = Object.keys(message.%s)).length) {", f.GetJsonName(), f.GetJsonName())
				j.Lf("object.%s = {};", f.GetJsonName())
				j.L("for (let i = 0; i < keys.length; ++i) {")
				j.Lf("object.%s[keys[i]] = %s;", f.GetJsonName(), c.objectConversionExpression(vf, "message."+f.GetJsonName()+"[keys[i]]"))
				j.L("}")
				j.L("}")
				continue
			}
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf(`if (message.%s && message.%s.length) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("object.%s = new Array(message.%s.length);", f.GetJsonName(), f.GetJsonName())
				j.Lf("for (let i = 0; i < message.%s.length; ++i) {", f.GetJsonName())
				j.Lf("object.%s[i] = %s;", f.GetJsonName(), c.objectConversionExpression(f, "message.%s[i]", f.GetJsonName()))
				j.Lf("}")
				j.Lf("}")
				continue
			}
			j.Lf(`if (message.%s != null && message.hasOwnProperty("%s")) {`, f.GetJsonName(), f.GetJsonName())
			j.Lf("object.%s = %s;", f.GetJsonName(), c.objectConversionExpression(f, "message.%s", f.GetJsonName()))
			if f.OneofIndex != nil && !f.GetProto3Optional() {
				j.L("if (options.oneofs) {")
				j.Lf(`object.%s = "%s";`, oneofFieldName(parentOneof(messageType, f)), f.GetJsonName())
				j.L("}")
			}
			j.L("}")
		}
		j.L("return object;")
		j.L("}")

		// toJSON
		d.L("toJSON(): Record<string, any>")

		// getTypeUrl
		d.L(`static getTypeUrl(typeUrlPrefix = "type.googleapis.com"): string;`)
		j.L(`static getTypeUrl(typeUrlPrefix = "type.googleapis.com") {`)
		j.Lf(`return typeUrlPrefix + "%s.%s";`, ns, messageType.GetName())
		j.L("}")

		// End class definition
		d.L("}")
		j.L("}")

		// Define prototype methods (note: not the same as static methods)
		j.Lf("%s.prototype.toJSON = function toJSON() {", messageType.GetName())
		j.L("return this.constructor.toObject(this, $protobuf.util.toJSONOptions);")
		j.L("}")

		// Assign defaults to class prototype instance
		for _, field := range messageType.GetField() {
			j.Lf("%s.prototype.%s = %s;", messageType.GetName(), field.GetJsonName(), c.defaultValueExpression(field))
		}

		// Generate sub-namespaces containing any nested messages and enums.
		// Don't generate map entry types explicitly since we generate native
		// map code instead.
		nestedMessageTypes := excludeMapEntries(messageType.GetNestedType())
		if len(nestedMessageTypes) > 0 || len(messageType.GetEnumType()) > 0 {
			d.Lf("export namespace %s {", messageType.GetName())
			c.generate(file, messagePath, messageType.GetName(), nestedMessageTypes, messageType.GetEnumType(), nil /*=services*/)
			d.L("}")
		}

		j.Lf("return %s;", messageType.GetName())
		j.L("})();")
	}

	// Generate enums
	for enumIndex, enumType := range enums {
		enumFieldTag := fileDescriptorEnumTypeTagNumber
		if len(sourcePath) > 0 {
			enumFieldTag = descriptorEnumTypeTagNumber
		}
		enumPath := append(sourcePath, enumFieldTag, int32(enumIndex))

		d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(enumPath)])
		d.Lf("export enum %s {", enumType.GetName())
		j.Lf("%s.%s = {", curNS, enumType.GetName())
		for valueIndex, value := range enumType.GetValue() {
			valuePath := append(enumPath, enumDescriptorValueTagNumber, int32(valueIndex))
			d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(valuePath)])
			d.Lf("%s = %d,", value.GetName(), value.GetNumber())
			j.Lf("%s: %d,", value.GetName(), value.GetNumber())
		}
		d.L("}")
		j.L("};")
	}

	// Generate services
	for serviceIndex, serviceType := range services {
		servicePath := append(sourcePath, fileDescriptorServiceTagNumber, int32(serviceIndex))
		d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(servicePath)])

		d.Lf("export interface I%s {", serviceType.GetName())
		for methodIndex, method := range serviceType.GetMethod() {
			methodPath := append(servicePath, serviceMethodTagNumber, int32(methodIndex))
			d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(methodPath)])
			d.Lf(
				`%s: { readonly name: "%s" } & ((request: %s) => Promise<%s>);`,
				methodName(method), method.GetName(), interfaceTypeName(c.resolveTypeName(method.GetInputType(), "")), c.resolveTypeName(method.GetOutputType(), ""))
		}
		d.L("}")

		d.Lf("export class %s extends $protobuf.rpc.Service implements I%s {", serviceType.GetName(), serviceType.GetName())
		j.Lf("%s.%s = (() => {", curNS, serviceType.GetName())
		j.Lf("class %s extends $protobuf.rpc.Service {", serviceType.GetName())

		d.L("constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited = false, responseDelimited = false);")
		j.L("constructor(rpcImpl, requestDelimited = false, responseDelimited = false) {")
		j.Lf("super(rpcImpl, requestDelimited, responseDelimited);")
		j.L("}")

		d.L("static create(rpcImpl: $protobuf.RPCImpl, requestDelimited = false, responseDelimited = false);")
		j.L("static create(rpcImpl, requestDelimited = false, responseDelimited = false) {")
		j.Lf("return new %s(rpcImpl, requestDelimited, responseDelimited);", serviceType.GetName())
		j.L("}")

		for _, method := range serviceType.GetMethod() {
			d.Lf(`%s!: I%s["%s"];`, methodName(method), serviceType.GetName(), methodName(method))
		}

		// End class definition
		d.L("}")
		j.L("}")

		// Define service methods on class prototype, including readonly "name" prop
		for _, method := range serviceType.GetMethod() {
			j.Lf(
				"Object.defineProperty(%s.prototype.%s = function %s(request, callback) {",
				serviceType.GetName(), methodName(method), methodName(method))
			j.Lf("return this.rpcCall(%s, %s, %s, request, callback);", methodName(method), c.resolveTypeName(method.GetInputType(), "$root."), c.resolveTypeName(method.GetOutputType(), "$root."))
			j.Lf(`}, "name", { value: "%s" });`, method.GetName())
		}

		j.Lf("return %s;", serviceType.GetName())
		j.L("})();")
	}
}

func (c *Codegen) resolveTypeName(name string, localPrefix string) string {
	importFile := c.Index.Files[c.Index.FilesByType[name].GetName()]
	for _, path := range c.Paths {
		// Type will be generated in the current output file; no need to import.
		if path == importFile.GetName() {
			return localPrefix + name[1:]
		}
	}
	if importFile == nil {
		fatalf("could not resolve import for %s")
	}
	if _, ok := importPaths[importFile.GetName()]; !ok && *strictImportsFlag {
		fatalf("-strict_imports failure: missing %q in -import_path entries %s", importFile.GetName(), *importPathFlag)
	}

	// Import the type, possibly with aliasing.
	resolvedImportPath := strings.TrimSuffix(importFile.GetName(), ".proto")
	// logf("prefixed import path (before prefixing): %s", prefixedImportPath)
	for protoPath, tsPath := range importPaths {
		if protoPath == importFile.GetName() {
			resolvedImportPath = tsPath
			break
		}
		if strings.HasSuffix(protoPath, "/") && strings.HasPrefix(resolvedImportPath, protoPath) {
			resolvedImportPath = filepath.Join(tsPath, strings.TrimPrefix(resolvedImportPath, protoPath))
			// logf("prefixed import path for %s -> %s", importFile.GetName(), prefixedImportPath)
			break
		}
	}

	importRelPath, err := filepath.Rel(filepath.Join(".", filepath.Dir(c.Out)), filepath.Join(".", resolvedImportPath))
	if err != nil {
		fatalf("failed to compute relpath: %s", err)
	}
	if !strings.HasPrefix(importRelPath, ".") {
		importRelPath = "./" + importRelPath
	}
	alias := ""
	if c.ImportedSymbols[importRelPath] != "" {
		alias = c.ImportedSymbols[importRelPath]
	}

	importPkg := strings.Split(name, ".")[1]
	// To keep things simple for now, alias all imported symbols even if they
	// don't conflict with any symbols in the scopes where they are referenced.
	if alias == "" {
		i := 0
		for i == 0 || (c.ImportedFiles[alias] != "" && c.ImportedFiles[alias] != importRelPath) {
			i++
			alias = fmt.Sprintf("%s$%d", importPkg, i)
		}
		c.ImportedFiles[alias] = importRelPath
		c.ImportedSymbols[importRelPath] = alias
		c.d.Import(importRelPath, importPkg, alias)
		c.j.Import(importRelPath, importPkg, alias)
	}

	parts := strings.Split(name, ".")
	parts[1] = alias
	resolved := strings.Join(parts[1:], ".")
	return resolved
}

func (c *Codegen) typeAnnotation(f *descriptorpb.FieldDescriptorProto) string {
	if c.isMapField(f) {
		entryType := c.Index.MessageTypes[f.GetTypeName()]
		kf := entryType.GetField()[0]
		vf := entryType.GetField()[1]
		return fmt.Sprintf("Record<%s, %s>", c.presentSingularTypeAnnotation(kf), c.presentSingularTypeAnnotation(vf))
	}
	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		return fmt.Sprintf("Array<%s>", c.presentSingularTypeAnnotation(f))
	}

	return c.singularTypeAnnotation(f)
}

func (c *Codegen) singularTypeAnnotation(f *descriptorpb.FieldDescriptorProto) string {
	a := c.presentSingularTypeAnnotation(f)
	if f.GetProto3Optional() {
		a += " | null | undefined /* optional */"
	} else if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		a += " | null | undefined"
	}
	return a
}

func (c *Codegen) presentSingularTypeAnnotation(f *descriptorpb.FieldDescriptorProto) string {
	if c.isLong(f.GetType()) {
		c.d.DefaultImport("long", "Long")
		c.j.DefaultImport("long", "Long")
		return "Long"
	}
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32:
		return "number"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "Uint8Array"
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		return c.resolveTypeName(f.GetTypeName(), "")
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		// TODO: support --noforce-message to allow interface types here?
		return c.resolveTypeName(f.GetTypeName(), "")
	default:
		typeName := f.GetTypeName()
		if typeName == "" {
			name := descriptorpb.FieldDescriptorProto_Type_name[int32(f.GetType())]
			typeName = strings.ToLower(strings.TrimPrefix(name, "TYPE_"))
		}
		fatalf("unsupported type %q for field %q", typeName, f.GetName())
		return "" // unreachable
	}
}

func (c *Codegen) isMapField(f *descriptorpb.FieldDescriptorProto) bool {
	return c.Index.MessageTypes[f.GetTypeName()].GetOptions().GetMapEntry()
}

func (c *Codegen) defaultValueExpression(f *descriptorpb.FieldDescriptorProto) string {
	// TODO: Respect [default] annotation

	// Map fields default to empty object
	if c.isMapField(f) {
		return "$util.emptyObject"
	}
	// Repeated fields (except for repeated MapEntry fields) default to empty
	// array
	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		return "$util.emptyArray"
	}

	if f.GetProto3Optional() {
		return "null"
	}

	t := f.GetType()
	if c.isLong(t) {
		return fmt.Sprintf("$util.Long ? $util.Long.fromBits(0, 0, %t) : 0", c.isUnsigned(t))
	}
	switch t {
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32:
		return "0"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "false"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "new Uint8Array()"
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return `""`
	case descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		return "0"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		return "null"
	default:
		return "undefined"
	}
}

func (c *Codegen) objectConversionExpression(f *descriptorpb.FieldDescriptorProto, expr string, args ...any) string {
	expr = fmt.Sprintf(expr, args...)
	if c.isLong(f.GetType()) {
		toNumberArg := ""
		if c.isUnsigned(f.GetType()) {
			toNumberArg = "true"
		}
		return fmt.Sprintf(
			`typeof %s === "number" ? (options.longs === String ? String(%s) : %s) : (options.longs === String ? $util.Long.prototype.toString.call(%s) : options.longs === Number ? new $util.LongBits(%s.low >>> 0, %s.high >>> 0).toNumber(%s) : %s)`,
			expr, expr, expr, expr, expr, expr, toNumberArg, expr)
	}
	if c.isFloatingPoint(f.GetType()) {
		return fmt.Sprintf(
			"options.json && !isFinite(%s) ? String(%s) : %s",
			expr, expr, expr)
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_BYTES {
		return fmt.Sprintf(
			"options.bytes === String ? $util.base64.encode(%s, 0, %s.length) : options.bytes === Array ? Array.prototype.slice.call(%s) : %s",
			expr, expr, expr, expr)
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		return fmt.Sprintf(
			"%s.toObject(%s, options)",
			c.resolveTypeName(f.GetTypeName(), "$root."), expr)
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
		return fmt.Sprintf(
			"options.enums === String ? %s[%s] === undefined ? %s : %s[%s] : %s",
			c.resolveTypeName(f.GetTypeName(), "$root."), expr, expr, c.resolveTypeName(f.GetTypeName(), "$root."), expr, expr,
		)
	}
	return expr
}

func (c *Codegen) enumZeroValue(f *descriptorpb.FieldDescriptorProto) *descriptorpb.EnumValueDescriptorProto {
	enumType := c.Index.EnumTypes[f.GetTypeName()]
	for _, v := range enumType.GetValue() {
		if v.GetNumber() == 0 {
			return v
		}
	}
	return nil
}

func wireType(f *descriptorpb.FieldDescriptorProto) int32 {
	switch f.GetType() {
	case
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64,
		descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		return i64WireType
	case descriptorpb.FieldDescriptorProto_TYPE_STRING,
		descriptorpb.FieldDescriptorProto_TYPE_BYTES,
		descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		return lenWireType
	case descriptorpb.FieldDescriptorProto_TYPE_GROUP:
		fatalf("groups are currently unsupported")
		return -1 // unreachable
	case descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		return i32WireType
	default:
		return varintWireType
	}
}

func isPackedField(f *descriptorpb.FieldDescriptorProto) bool {
	// If the "packed" option is set explicitly, return it.
	if f.Options != nil && f.Options.Packed != nil {
		return *f.Options.Packed
	}
	return isPackableField(f)
}

func isPackableField(f *descriptorpb.FieldDescriptorProto) bool {
	// Only repeated fields can be packed
	if f.GetLabel() != descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		return false
	}
	// Message types cannot be packed
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		return false
	}
	switch wireType(f) {
	case varintWireType, i64WireType, i32WireType:
		return true
	default:
		return false
	}
}

// Returns the protobufjs reader/writer method corresponding to the given field
// type.
func encodeMethodName(f *descriptorpb.FieldDescriptorProto) string {
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
		return "int32"
	}
	name := descriptorpb.FieldDescriptorProto_Type_name[int32(f.GetType())]
	return strings.ToLower(strings.TrimPrefix(name, "TYPE_"))
}

func (c *Codegen) isUnsigned(t descriptorpb.FieldDescriptorProto_Type) bool {
	switch t {
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32:
		return true
	default:
		return false
	}
}

func (c *Codegen) isLong(t descriptorpb.FieldDescriptorProto_Type) bool {
	switch t {
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64:
		return true
	default:
		return false
	}
}

func (c *Codegen) isFloatingPoint(t descriptorpb.FieldDescriptorProto_Type) bool {
	return t == descriptorpb.FieldDescriptorProto_TYPE_DOUBLE || t == descriptorpb.FieldDescriptorProto_TYPE_FLOAT
}

func excludeMapEntries(messageTypes []*descriptorpb.DescriptorProto) []*descriptorpb.DescriptorProto {
	out := make([]*descriptorpb.DescriptorProto, 0, len(messageTypes))
	for _, m := range messageTypes {
		if m.GetOptions().GetMapEntry() {
			continue
		}
		out = append(out, m)
	}
	return out
}

func debugf(format string, args ...any) {
	if os.Getenv("DEBUG") == "1" {
		fmt.Fprintf(os.Stderr, "DEBUG(protoc-gen-protobufjs): "+format+"\n", args...)
	}
}

func logf(format string, args ...any) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
}

func fatalf(format string, args ...any) {
	logf("FATAL(protoc-gen-protobufjs): "+format, args...)
	os.Exit(1)
}

func readRequest() (*pluginpb.CodeGeneratorRequest, error) {
	b, err := io.ReadAll(os.Stdin)
	if err != nil {
		return nil, err
	}
	req := &pluginpb.CodeGeneratorRequest{}
	if err := proto.Unmarshal(b, req); err != nil {
		return nil, err
	}
	return req, nil
}

func writeResponse(res *pluginpb.CodeGeneratorResponse) error {
	b, err := proto.Marshal(res)
	if err != nil {
		return err
	}
	if _, err := os.Stdout.Write(b); err != nil {
		return err
	}
	return nil
}

func parentOneof(message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) *descriptorpb.OneofDescriptorProto {
	return message.OneofDecl[field.GetOneofIndex()]
}

func oneofFieldName(decl *descriptorpb.OneofDescriptorProto) string {
	parts := strings.Split(decl.GetName(), "_")
	if len(parts) == 0 {
		return ""
	}
	out := parts[0]
	for _, p := range parts[1:] {
		if out == "" {
			out += "_" + p
			continue
		}
		if len(p) == 0 {
			continue
		}
		out += strings.ToUpper(p[:1]) + p[1:]
	}
	return out
}

func methodName(method *descriptorpb.MethodDescriptorProto) string {
	return strings.ToLower(method.GetName()[:1]) + method.GetName()[1:]
}

func getPart(value, split string, index int) string {
	parts := strings.Split(value, split)
	if index < 0 {
		index = len(parts) + index
	}
	return parts[index]
}

func interfaceTypeName(typeName string) string {
	typeName = strings.TrimPrefix(typeName, ".")
	parts := strings.Split(typeName, ".")
	parts[len(parts)-1] = "I" + parts[len(parts)-1]
	return strings.Join(parts, ".")
}
